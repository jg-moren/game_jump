#include <windows.h>
#include <GL/gl.h>
#include <GL/glut.h>
#include <stdio.h>



#include "obj_blocos.cpp"
#include "LoadMap.cpp"
class obj_sala1{

	public:
		int mapa [10][10][10]={
		{{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,1,0,0,0,0,0,0,0,0},{1,0,1,0,0,0,0,0,0,0},{1,0,0,1,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,1,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,1,0,0,0,0,0,0},{1,0,0,1,0,0,0,0,0,0},{1,0,0,1,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}},
		{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,1}}
		};
		int rows = sizeof(mapa)/sizeof(mapa[0]);
		int cols = sizeof(mapa[0])/(sizeof mapa[0][0]);
		int alto = sizeof(mapa[0][0])/(sizeof mapa[0][0][0]);
		
		void sala(){	
		float coo [3];


		glPushMatrix();
		loadMap load;
		load.LoadBMP("ter.bmp");
		obj_blocos blocos;


		
		GLfloat especular[4]={1.0,1.0,1.0,1.0};
		glMaterialfv(GL_FRONT,GL_SPECULAR, especular);
		glMateriali(GL_FRONT,GL_SHININESS,10);
		glColor3f(1,1,1);
		for(int i1=0;i1<rows;i1+=1){
		for(int i2=0;i2<cols;i2+=1){
		for(int i3=0;i3<alto;i3+=1){
	//	glutSolidSphere(1.5,100,100);		
	//	glutSolidCube(1.5);
		glPushMatrix();
		glRotatef(0,1,0,0);
		glTranslatef(0,-1,0);
		
		if(mapa[i1][i2][i3]==1){
		coo[0]=i2;
		coo[1]=i3;
		coo[2]=i1;
		blocos.bloco1(coo);
		}
		

		glPopMatrix();		
		
		}
		}
		}
		glPopMatrix();
}
		
		float colisao0(float coo [3] ){ 
			if(coo[1]<-10){
				return 0;
			}
			if(0<=coo[0] && coo[0]<=cols){
			 if(mapa[(int)coo[2]] [(int)(coo[0]-0.15)] [(int)coo[1]]  ==1 /*&& coo[1]>(int)coo[0]+0.1*/){
				return (int)coo[0]+0.2;
			}if(mapa[(int)coo[2]] [(int)(coo[0]+0.15)] [(int)coo[1]]  ==1 /*&& coo[1]<(int)coo[0]+0.9*/){
				return (int)coo[0]+0.8;
			}else{
				return coo[0]; 
			}
			}else{
				//
				if(coo[0]>cols)return (float)cols-0.01;
				if(0>=coo[0]   )return 0;
			}
		
			// or  
			// int *temp_arr = (int *) malloc(sizeof(int) * arr_size); 
 
			//your code goes here :) 
			//return coo[0]; 
		} 
		float colisao1(float coo [3]){ 
			if(coo[1]<-100){
				return 2;
			}
			if(0<=coo[1] && coo[1]<=alto){
			if(mapa[(int)coo[2]] [(int)coo[0]] [(int)coo[1]]  ==1  /*&& coo[1]>(int)coo[1]+0.1*/){
				return (int)coo[1]+1;
			}else{
				return coo[1]; 
			}
			}else{
				return coo[1]; 
			}
			// or  
			// int *temp_arr = (int *) malloc(sizeof(int) * arr_size); 
 
			//your code goes here :) 
			
		} 
		float colisao2(float coo [3]){ 
			if(coo[1]<-10){
				return 0;
			}
			if(0<=coo[2] && coo[2]<=rows){
			 if(mapa [(int)(coo[2]-0.15)] [(int)coo[0]] [(int)coo[1]]  ==1 ){
				return (int)coo[2]+0.2;
			}if(mapa [(int)(coo[2]+0.15)] [(int)coo[0]]  [(int)coo[1]]  ==1){
				return (int)coo[2]+0.8;
			}else{
				return coo[2]; 
			}
			}
			if(coo[2]>rows)return (float)rows-0.01;	
			if(0>=coo[2] )return 0;
			
			
			// or  
			// int *temp_arr = (int *) malloc(sizeof(int) * arr_size); 
 
			//your code goes here :) 
			return coo[2]; 
		} 
		float pulo (float coo [3],float impulso){
			if(-1<=coo[1] ){
				
			if(mapa[(int)coo[2]] [(int)coo[0]] [(int)(coo[1]-0.1)]  ==1/* && coo[1]<(int)coo[1]+0.1*/){
				return 0;
			}if(mapa[(int)coo[2]] [(int)coo[0]] [(int)coo[1]+1]  ==1 && coo[1]>(int)coo[1]){
				return -0.1;
			}else{
				return impulso;
			}
			}else{
				return -1.5;
			}
			
		}
		
		bool contpulo(float coo[3],bool pulos){
			if(mapa[(int)coo[2]] [(int)coo[0]] [(int)(coo[1]-0.1)]  ==1){
				return true;
			}else{
				return pulos;
			}
		}

		
	
};
